<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Markdown 到 XML 转换器</title>
	<style>
		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}
		
		body {
			font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
			line-height: 1.6;
			color: #333;
			background: linear-gradient(135deg, #f5f7fa 0%, #e4edf5 100%);
			padding: 20px;
			min-height: 100vh;
		}
		
		.container {
			max-width: 1400px;
			margin: 0 auto;
		}
		
		header {
			text-align: center;
			margin-bottom: 30px;
			padding: 20px;
			background: rgba(255, 255, 255, 0.9);
			border-radius: 10px;
			box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
		}
		
		h1 {
			color: #2c3e50;
			margin-bottom: 10px;
			font-size: 2rem;
		}
		
		.subtitle {
			color: #7f8c8d;
			font-size: 1.2rem;
			max-width: 800px;
			margin: 0 auto;
		}
		
		.converter-container {
			display: flex;
			gap: 25px;
			margin-bottom: 25px;
			flex-wrap: wrap;
		}
		
		.panel {
			flex: 1;
			min-width: 300px;
			background: white;
			border-radius: 10px;
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
			overflow: hidden;
			display: flex;
			flex-direction: column;
			height: 600px;
		}
		
		.panel-header {
			background: #3498db;
			color: white;
			padding: 15px 20px;
			font-weight: 600;
			display: flex;
			align-items: center;
			justify-content: space-between;
		}
		
		.panel-header.left {
			background: #3498db;
		}
		
		.panel-header.right {
			background: #27ae60;
		}
		
		.file-indicator {
			font-size: 0.85rem;
			opacity: 0.9;
			background: rgba(0, 0, 0, 0.15);
			padding: 3px 10px;
			border-radius: 20px;
		}
		
		.panel-content {
			flex: 1;
			padding: 0;
			position: relative;
			overflow: hidden;
		}
		
		textarea {
			width: 100%;
			height: 100%;
			padding: 20px;
			border: none;
			resize: none;
			font-family: 'Consolas', 'Courier New', monospace;
			font-size: 15px;
			line-height: 1.5;
			outline: none;
			background: #fcfdfe;
			min-height: 100%;
			box-sizing: border-box;
			overflow: auto;
		}
		
		textarea#xmlOutput {
			color: #2c3e50;
		}
		
		.drop-overlay {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: rgba(52, 152, 219, 0.9);
			display: flex;
			align-items: center;
			justify-content: center;
			color: white;
			font-size: 1.5rem;
			font-weight: bold;
			border: 3px dashed white;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.3s;
			z-index: 10;
		}
		
		.drop-overlay.active {
			opacity: 1;
		}
		
		.controls {
			display: flex;
			justify-content: center;
			gap: 15px;
			margin-top: 15px;
			flex-wrap: wrap;
		}
		
		.btn {
			padding: 12px 30px;
			border: none;
			border-radius: 50px;
			font-size: 1rem;
			font-weight: 600;
			cursor: pointer;
			transition: all 0.3s ease;
			display: flex;
			align-items: center;
			gap: 8px;
		}
		
		.btn-convert {
			background: #3498db;
			color: white;
			box-shadow: 0 4px 10px rgba(52, 152, 219, 0.4);
		}
		
		.btn-convert:hover {
			background: #2980b9;
			transform: translateY(-2px);
		}
		
		.btn-copy {
			background: #27ae60;
			color: white;
			box-shadow: 0 4px 10px rgba(39, 174, 96, 0.4);
		}
		
		.btn-copy:hover {
			background: #219653;
			transform: translateY(-2px);
		}
		
		.btn:active {
			transform: translateY(1px);
		}
		
		.instructions {
			margin: 40px auto 20px;
			background: white;
			padding: 25px;
			border-radius: 10px;
			box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
		}
		
		.instructions h2 {
			color: #2c3e50;
			margin-bottom: 20px;
			padding-bottom: 10px;
			border-bottom: 2px solid #3498db;
		}
		
		.markdown-specs {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
			gap: 20px;
			margin-top: 20px;
		}
		
		.spec-card {
			background: #f8f9fa;
			border-radius: 8px;
			padding: 20px;
			border-left: 4px solid #3498db;
			transition: transform 0.3s;
		}
		
		.spec-card:hover {
			transform: translateY(-5px);
		}
		
		.spec-card h3 {
			color: #2c3e50;
			margin-bottom: 12px;
			font-size: 1.2rem;
		}
		
		.spec-card ul {
			padding-left: 20px;
		}
		
		.spec-card li {
			margin-bottom: 8px;
			line-height: 1.4;
		}
		
		.spec-card code {
			background: #eef2f7;
			padding: 2px 6px;
			border-radius: 4px;
			font-family: monospace;
			font-size: 0.95rem;
		}
		
		.example {
			margin-top: 15px;
			padding: 12px;
			background: #eef7ff;
			border-radius: 6px;
			font-size: 0.9rem;
		}
		
		.highlight {
			color: #e74c3c;
			font-weight: 600;
		}
		
		.status-bar {
			background: #f8f9fa;
			padding: 10px 15px;
			border-top: 1px solid #eee;
			font-size: 0.9rem;
			display: flex;
			justify-content: space-between;
		}
		
		@media (max-width: 768px) {
			.converter-container {
				flex-direction: column;
			}
			
			.panel {
				min-width: 100%;
				height: 450px;
			}
		}
	</style>
</head>
<body>
	<div class="container">
		<header>
			<h1>longyusheng.org Markdown 到 XML 转换器</h1>
		</header>
		
		<div class="converter-container">
			<div class="panel">
				<div class="panel-header left">
					<span>Markdown 输入</span>
					<span class="file-indicator">支持 .md 文件拖放</span>
					<button class="btn btn-convert" id="convertBtn">
						<svg width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
							<path d="M8 1a7 7 0 0 0-7 7 7 7 0 0 0 7 7 7 7 0 0 0 7-7 7 7 0 0 0-7-7zm0 11.5a4.5 4.5 0 1 1 0-9 4.5 4.5 0 0 1 0 9zM5 8a1 1 0 1 1 2 0 1 1 0 0 1-2 0z"/>
						</svg>
						转换
					</button>
				</div>
				<div class="panel-content">
					<textarea id="markdownInput" placeholder="在此输入Markdown内容或拖放.md文件..."># 第一讲　唐宋歌词的特殊形式和发展规律

## 概述
《词学十讲》是根据<u>龙榆生</u>先生<sup>[1]</sup>词学学习创作课上讲义编辑而成的著作，深入浅出地讲解了词学渊源、选调、作法等内容。

> [! 注]
[1] 附注一。

词不称“作”而称“填”，因为它要受声律的严格约束，不像散文可以自由抒写。

## 唐宋歌词的发展
每一曲调的构成，它的轻重缓急和节奏关系，必得和作者所要表达的起伏变化的感情相应。

这种“因声以度词，审调以节唱，句度短长之数，声韵平上之差，莫不由之准度”<sub>（见《元氏长庆集》卷二十三《乐府古题序》）</sub>的歌词形式，原来是古已有之的。

> 唐武德[1]（唐高祖李渊年号）初，因隋旧制，用九部乐。太宗（李世民）增《高昌乐》，又造《燕乐》而去《毕礼曲》。
> ——郭茂倩《乐府诗集》

> [! 注]
[1] **附注二**。

### 刘禹锡的贡献
例如刘禹锡《和乐天春词》：

> 春去也！多谢【洛城】人－。
> 弱柳从风疑举袂，丛兰浥露似沾巾－，
> 独坐亦含嚬－。
> ——《刘梦得外集》卷四

他就在题内说明：“依《[忆江南](?fmt=忆江南)曲拍为句。”这是身负重名的诗人有意依照新兴曲调的节拍来填写长短句歌词的有力证据。

## 相关词作
- [刘禹锡《潇湘神》]($lyx-xxs-xiangshuiliu)
- [刘禹锡《浪淘沙》]($lyx-langtaosha)
- [李煜《浪淘沙》]($ly-lts-lianwaiyuchan)

## 结论
由于此类歌曲多流行于市井间，以渐跻于士大夫的歌筵舞席上，作为娱宾遣兴之资，内容是比较贫乏的。</textarea>
					<div class="drop-overlay" id="dropOverlay">拖放文件到此处</div>
				</div>
				<div class="status-bar">
					<span>行数: <span id="lineCount">0</span></span>
					<span>字符数: <span id="charCount">0</span></span>
				</div>
			</div>
			
			<div class="panel">
				<div class="panel-header right">
					<span>XML 输出</span>
					<button class="btn btn-copy" id="copyBtn">
						<svg width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
							<path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/>
							<path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/>
						</svg>
						复制 XML
					</button>
				</div>
				<div class="panel-content">
					<textarea id="xmlOutput" readonly></textarea>
				</div>
				<div class="status-bar">
					<span>转换状态: <span id="conversionStatus">等待输入</span></span>
					<span>XML大小: <span id="xmlSize">0 KB</span></span>
				</div>
			</div>
		</div>
		
		<div class="controls">
		</div>
		
		<div class="instructions">
			<h2>Markdown 格式规范</h2>
			<p>以下是根据"article.xsd"架构定义的Markdown格式规范：</p>
			
			<div class="markdown-specs">
				<div class="spec-card">
					<h3>基本结构</h3>
					<ul>
						<li><code># 标题</code> - 文章标题</li>
						<li><code>## 概述</code> - 文章概述部分</li>
						<li><code>## 正文</code> - 正文内容开始</li>
						<li><code>### 副标题</code> - 副标题</li>
						<li><code>#### 小标题</code> - 小标题</li>
					</ul>
				</div>
				
				<div class="spec-card">
					<h3>特殊元素</h3>
					<ul>
						<li><code>**着重内容**</code> - 着重元素</li>
						<li><code>*引用内容*</code> - 引用元素</li>
						<li><code>&lt;u&gt;专名&lt;/u&gt;</code> - 专名元素</li>
						<li><code>![图片说明](src.jpg)</code> - 图片元素</li>
						<li><code>- 列举项</code> - 无序列表</li>
						<li><code>1. 列举项</code> - 有序列表</li>
						<li><code>&lt;sub&gt;...&lt;/sub&gt;</code> - 注释</li>
						<li><code>==内容==&lt;sup&gt;1&lt;/sup&gt;</code> - 引用附注</li>
					</ul>
				</div>
				
				<div class="spec-card">
					<h3>链接格式</h3>
					<ul>
						<li><code>[文本](#)</code> - 传记链接</li>
						<li><code>[文本](@词集名)</code> - 词集链接</li>
						<li><code>[文本]($词ID)</code> - 特选词作</li>
						<li><code>[文本](?a=档案ID)</code> - 档案链接</li>
						<li><code>[文本](?f=文章ID)</code> - 文章链接</li>
						<li><code>[文本](?fmt=词牌名)</code> - 词牌格式</li>
					</ul>
				</div>
				
				<div class="spec-card">
					<h3>引文格式</h3>
					<div class="example">
						<p>&gt; 引文内容...</p>
						<p>&gt; 可以有多行</p>
						<p>&gt; ——引文出处</p>
					</div>
					<p>转换结果:</p>
					<div class="example">
						<code>&lt;引文&gt;</code><br>
						<code>&lt;引用&gt;...&lt;/引用&gt;</code><br>
						<code>&lt;出处&gt;...&lt;/出处&gt;</code><br>
						<code>&lt;/引文&gt;</code>
					</div>
				</div>
			</div>
		</div>
	</div>

	<script>
		document.addEventListener('DOMContentLoaded', function() {
			const markdownInput = document.getElementById('markdownInput');
			const xmlOutput = document.getElementById('xmlOutput');
			const convertBtn = document.getElementById('convertBtn');
			const copyBtn = document.getElementById('copyBtn');
			const dropOverlay = document.getElementById('dropOverlay');
			const lineCount = document.getElementById('lineCount');
			const charCount = document.getElementById('charCount');
			const conversionStatus = document.getElementById('conversionStatus');
			const xmlSize = document.getElementById('xmlSize');
			
			// 更新字符和行数统计
			function updateStats() {
				const text = markdownInput.value;
				charCount.textContent = text.length;
				lineCount.textContent = text.split('\n').length;
			}
			
			// 初始统计
			updateStats();
			markdownInput.addEventListener('input', updateStats);
			
			// 转换按钮事件
			convertBtn.addEventListener('click', convertMarkdownToXML);
			
			// 复制按钮事件
			copyBtn.addEventListener('click', function() {
				xmlOutput.select();
				document.execCommand('copy');
				
				// 显示复制成功反馈
				const originalText = copyBtn.innerHTML;
				copyBtn.innerHTML = '<svg width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"/></svg> 已复制!';
				
				setTimeout(() => {
					copyBtn.innerHTML = originalText;
				}, 2000);
			});
			
			// 拖放功能
			markdownInput.addEventListener('dragover', function(e) {
				e.preventDefault();
				dropOverlay.classList.add('active');
			});
			
			markdownInput.addEventListener('dragleave', function() {
				dropOverlay.classList.remove('active');
			});
			
			markdownInput.addEventListener('drop', function(e) {
				e.preventDefault();
				dropOverlay.classList.remove('active');
				
				const file = e.dataTransfer.files[0];
				if (file && file.name.endsWith('.md')) {
					conversionStatus.textContent = '正在加载文件...';
					const reader = new FileReader();
					reader.onload = function(e) {
						markdownInput.value = e.target.result;
						updateStats();
						convertMarkdownToXML();
						conversionStatus.textContent = '文件已加载';
					};
					reader.readAsText(file);
				} else {
					alert('请拖放一个 .md 文件');
					conversionStatus.textContent = '错误：非Markdown文件';
				}
			});
			
			// 初始转换
			convertMarkdownToXML();
			
			// Markdown 到 XML 转换函数（优化版）
			function convertMarkdownToXML() {
				try {
					conversionStatus.textContent = '正在转换...';
					const startTime = performance.now();
		
					const markdown = markdownInput.value;
					let xml = '<档案文章>\n';
					let notes = []; // 存储附注内容
					let bodyContent = '';
		
					// 解析标题
					const titleMatch = markdown.match(/^#\s+(.+)$/m);
					if (titleMatch) {
						const processedTitle = convertInlineElements(titleMatch[1]);
						const escapedTitle = escapeMixedContent(processedTitle);
						xml += `\t<标题>${escapedTitle}</标题>\n`;
		
						// 获取标题后的内容
						const afterTitle = markdown.substring(titleMatch.index + titleMatch[0].length);
						const trimmedAfterTitle = afterTitle.trimLeft();

						// 查找概述部分
						const overviewMatch = trimmedAfterTitle.match(/^##\s+概述\n([\s\S]*?)(?=^##\s|\n##\s|$)/m);

						if (overviewMatch) {
							// 处理概述部分
							xml += '\t<概述>\n';
							xml += convertContentToXML(overviewMatch[1].trim());
							xml += '\t</概述>\n';
							
							// 提取概述后的内容作为正文
							const afterOverview = trimmedAfterTitle.substring(overviewMatch.index + overviewMatch[0].length).trimLeft();
							if (afterOverview) {
								bodyContent = extractNotesAndFilterBody(afterOverview.trim(), notes);
							}
						} else {
							// 没有概述部分，整个内容作为正文
							bodyContent = extractNotesAndFilterBody(trimmedAfterTitle, notes);
						}
					} else {
						// 没有标题的情况：尝试查找概述和正文
						const overviewMatch = markdown.match(/##\s+概述\n([\s\S]*?)(?=##|$)/);
						if (overviewMatch) {
							xml += '\t<概述>\n';
							xml += convertContentToXML(overviewMatch[1].trim());
							xml += '\t</概述>\n';
						}
						
						const bodyMatch = markdown.match(/##\s+正文\n([\s\S]*)/);
						if (bodyMatch) {
							bodyContent = extractNotesAndFilterBody(bodyMatch[1].trim(), notes);
						} else if (!overviewMatch) {
							// 没有标题、概述或正文，整个内容作为正文
							bodyContent = extractNotesAndFilterBody(markdown, notes);
						}
					}

					// 转换正文
					xml += '\t<正文>\n';
					xml += convertContentToXML(bodyContent);
					xml += '\t</正文>\n';

					// 添加附注部分
					if (notes.length > 0) {
						xml += '\t<附注>\n';
						notes.forEach((note, index) => {
							note = note.replace(/^[^。]+?：/, "");
							const processedNote = convertInlineElements(note);
							const escapedNote = escapeMixedContent(processedNote);
							xml += `\t\t<段落 id="${index + 1}">${escapedNote}</段落>\n`;
						});
						xml += '\t</附注>\n';
					}
					xml += '</档案文章>';
		
					// 更新XML输出
					xmlOutput.value = xml;
		
					// 更新状态信息
					const endTime = performance.now();
					const timeTaken = (endTime - startTime).toFixed(2);
					xmlSize.textContent = (xml.length / 1024).toFixed(2) + ' KB';
					conversionStatus.textContent = `转换成功 (${timeTaken}ms)`;
				} catch (error) {
					console.error('转换错误:', error);
					conversionStatus.textContent = '错误: ' + error.message;
					xmlOutput.value = '<!-- 转换过程中发生错误 -->\n' + 
									  '<!-- ' + error.message + ' -->';
				}
			}

			// 提取正文内容并预处理附注
			function extractNotesAndFilterBody(content, notes) {
				let lines = content.split('\n');
				let newLines = [];
				let inNoteBlock = false;
				let currentNote = null;

				for (let i = 0; i < lines.length; i++) {
					const line = lines[i];
					const trimmedLine = line.trim();
					
					// 检测注块开始
					if (trimmedLine === '> [! 注]') {
						inNoteBlock = true;
						currentNote = null;
						continue;
					}
					
					// 处理注块内容
					if (inNoteBlock) {
						// 遇到空行结束附注块
						if (trimmedLine === '') {
							if (currentNote) {
								notes.push(currentNote);
							}
							inNoteBlock = false;
							currentNote = null;
							continue;
						}
						
						// 检测附注项 (如 > [1] ...)
						const noteMatch = line.match(/^>?\s*\[(\d+)\]\s*(.+)/);
						if (noteMatch) {
							if (currentNote) {
								notes.push(currentNote);
							}
							currentNote = noteMatch[2];
						} 
						// 检测普通附注行（可选>前缀）
						else if (line.startsWith('>') || currentNote) {
							const contentLine = line.replace(/^>\s*/, '');
							if (currentNote) {
								currentNote += '\n' + contentLine;
							} else {
								currentNote = contentLine;
							}
						}
						// 非附注行结束附注块
						else {
							if (currentNote) {
								notes.push(currentNote);
							}
							inNoteBlock = false;
							currentNote = null;
							newLines.push(line);
						}
					} else {
						newLines.push(line);
					}
				}
				
				// 处理最后一个附注
				if (inNoteBlock && currentNote) {
					notes.push(currentNote);
				}
				
				return newLines.join('\n');
			}
			
			// 将Markdown内容转换为XML
			function convertContentToXML(content) {
				let xml = '';
				const lines = content.split('\n');
				let inBlockquote = false;
				let blockquoteContent = [];
				let inList = false;
				let listItems = [];
				
				for (let i = 0; i < lines.length; i++) {
					const line = lines[i].trim();
					
					// 处理二级标题（除了"概述"和"正文"）
					if (line.startsWith('## ')) {
						const titleText = line.substring(3).trim();
						// 排除"概述"和"正文"这两个特殊标题
						if (titleText !== '概述' && titleText !== '正文') {
							// 结束之前的列表和引文
							if (inList) {
								xml += convertListToXML(listItems);
								inList = false;
								listItems = [];
							}
							if (inBlockquote) {
								xml += convertBlockquoteToXML(blockquoteContent);
								inBlockquote = false;
							}
							
							const processedTitle = convertInlineElements(titleText);
							const escapedTitle = escapeMixedContent(processedTitle);
							xml += `\n\t\t<副标题>${escapedTitle}</副标题>\n`;
							continue; // 跳过后续处理
						}
					}
					// 处理小标题（三级标题）
					if (line.startsWith('### ')) {
						// 结束之前的列表
						if (inList) {
							xml += convertListToXML(listItems);
							inList = false;
							listItems = [];
						}
						if (inBlockquote) {
							xml += convertBlockquoteToXML(blockquoteContent);
							inBlockquote = false;
						}
						
						const processedTitle = convertInlineElements(line.substring(4));
						const escapedTitle = escapeMixedContent(processedTitle);
						xml += `\n\t\t<小标题>${escapedTitle}</小标题>\n`;
					}
					// 处理引文
					else if (line.startsWith('>')) {
						if (inList) {
							xml += convertListToXML(listItems);
							inList = false;
							listItems = [];
						}
						
						if (!inBlockquote) {
							inBlockquote = true;
							blockquoteContent = [];
						}
						const contentLine = line.substring(1).trim();
						blockquoteContent.push(contentLine);
					}
					// 处理列表
					else if (line.startsWith('- ') || /^\d+\.\s/.test(line)) {
						if (inBlockquote) {
							xml += convertBlockquoteToXML(blockquoteContent);
							inBlockquote = false;
						}
						
						if (!inList) {
							inList = true;
						}
						const listItem = line.replace(/^[-0-9.]+?\s+/, '');
						listItems.push(listItem);
					}
					// 处理图片
					else if (line.startsWith('![')) {
						if (inList) {
							xml += convertListToXML(listItems);
							inList = false;
							listItems = [];
						}
						if (inBlockquote) {
							xml += convertBlockquoteToXML(blockquoteContent);
							inBlockquote = false;
						}
						
						const match = line.match(/!\[(.*?)\]\((.*?)\)/);
						if (match) {
							xml += `\t\t<图片 src="${escapeXML(match[2])}">${escapeXML(match[1])}</图片>\n`;
						}
					}
					// 处理段落
					else if (line) {
						// 结束之前的块
						if (inList) {
							xml += convertListToXML(listItems);
							inList = false;
							listItems = [];
						}
						if (inBlockquote) {
							xml += convertBlockquoteToXML(blockquoteContent);
							inBlockquote = false;
						}
						
						// 在普通段落处理中
						const processedLine = convertInlineElements(line);
						// 只转义纯文本部分（跳过已生成的XML标签）
						const finalLine = escapeMixedContent(processedLine);
						xml += `\t\t<段落>${finalLine}</段落>\n`;
					}
				}
				
				// 处理最后的块
				if (inList) {
					xml += convertListToXML(listItems);
				}
				if (inBlockquote) {
					xml += convertBlockquoteToXML(blockquoteContent);
				}
				
				return xml;
			}
			
			// 转换列表为XML
			function convertListToXML(items) {
				if (items.length === 0) return '';
				
				let xml = '\t\t<列举项>\n';
				for (const item of items) {
					xml += `\t\t\t<项目>${convertInlineElements(item)}</项目>\n`;
				}
				xml += '\t\t</列举项>\n';
				return xml;
			}
			
			// 转换引文块
			function convertBlockquoteToXML(content) {
				if (content.length === 0) return '';
				
				let xml = '';
				let quoteContent = [];
				let source = '';
				let isCi = false;
				
				// 查找出处和词韵标识
				for (let i = 0; i < content.length; i++) {
					const contentLine = content[i];
					if (!isCi) {
						isCi = contentLine.indexOf('<font') != -1;
					}
					if (contentLine.startsWith('——')) {
						source = contentLine.substring(2);
					} else {
						quoteContent.push(contentLine);
					}
				}
				
				if (quoteContent.length > 1) {
					xml += '\t\t<引文>\n';
					if (isCi) {
						xml += `\t\t\t<引用><![CDATA[${convertCiMarkup(quoteContent.join('\n'))}]]></引用>\n`;
					}
					else {
						xml += `\t\t\t<引用>${convertInlineElements(quoteContent.join('\n'))}</引用>\n`;
					}
				
					if (source) {
						xml += `\t\t\t<出处>${escapeXML(source)}</出处>\n`;
					}
					
					xml += '\t\t</引文>\n';
					return xml;
				}
				else if (quoteContent.length === 1) {
					if (source || isCi) {
						xml += '\t\t<引文>';
						if (isCi) {
							xml += `\n\t\t\t<引用><![CDATA[${convertCiMarkup(quoteContent[0])}]]></引用>\n`;
						}
						else {
							xml += convertInlineElements(quoteContent[0]);
							xml += `<出处>${escapeXML(source)}</出处></引文>\n`
						}
						xml += `\t\t</引文>\n`;
						return xml;
					}
					return `\t\t<引文>${convertInlineElements(quoteContent[0])}</引文>\n`;
				}
				else {
					return '';
				}
			}
			
			// 转换内联元素
			function convertInlineElements(text) {
				// 转换着重
				text = text.replace(/\*\*(.*?)\*\*/g, '<着重>$1</着重>');
	
				// 转换引用
				text = text.replace(/\*(.*?)\*/g, '<引用>$1</引用>');
	
				// 转换专名（保留<u>标签）
				text = text.replace(/<u>(.*?)<\/u>/g, '<专名>$1</专名>');

				// 转换注释标签（将<sub>转换为<注释>）
				text = text.replace(/<sub>(.*?)<\/sub>/g, '<注释>$1</注释>');

				// 转换引用附注标签（将<sup>转换为<引用附注>）
				text = text.replace(/==(.+?)==<sup>\[(\d+)\]<\/sup>/g, '<引用附注 id="$2">$1</引用附注>')
						.replace(/([^=])<sup>\[(\d+)\]<\/sup>/g, '<引用附注 id="$2">$1</引用附注>');
	
				// 转换链接 - 只对URL部分进行转义
				text = text.replace(/\[(.*?)\]\((.*?)\)/g, function(match, text, url) {
					return `<链接 xhref="${escapeXML(url)}">${text}</链接>`;
				});
	
				return text; // 直接返回包含XML标签的字符串
			}
			// 转换带有标记的词作品
			function convertCiMarkup(text){
				// 转换专名
				text = text.replace(/<u>(.*?)<\/u>/g, '【$1】');

				// 转换韵脚标记
				text = text.replace(/<font color="#c00000">(.)<\/font>/g, '$1＾');
				text = text.replace(/<font color="#0070c0">(.)<\/font>/g, '$1－');

				text = text.replace(/([＾－])】/, '】$1');
				return text;
			}
			
			// XML转义
			function escapeXML(str) {
				return str.replace(/&/g, '&amp;')
						  .replace(/</g, '&lt;')
						  .replace(/>/g, '&gt;')
						  .replace(/"/g, '&quot;')
						  .replace(/'/g, '&apos;');
			}
			function escapeMixedContent(str) {
				let result = '';
				let inTag = false;
				let buffer = '';
	
				for (let i = 0; i < str.length; i++) {
					const char = str[i];
		
					if (char === '<') {
						// 处理标签前的文本
						if (buffer) {
							result += escapeXML(buffer);
							buffer = '';
						}
						inTag = true;
						result += char;
					} 
					else if (char === '>') {
						result += char;
						inTag = false;
					} 
					else if (inTag) {
						result += char;
					} 
					else {
						buffer += char;
					}
				}
	
				// 处理结尾的文本
				if (buffer) {
					result += escapeXML(buffer);
				}
	
				return result;
			}
		});
	</script>
</body>
</html>